当然，这是一个基本的发布者和订阅者的例子。在这个例子中，我们将创建一个发布者节点，它会发布一个字符串消息，然后创建一个订阅者节点，它会接收并打印这个消息。

首先，我们需要创建一个新的ROS2工作空间和一个新的包。在你的终端中，运行以下命令：

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_cmake hello_ros2 --dependencies rclcpp
```

然后，我们需要在`hello_ros2`包中创建两个C++文件，一个用于发布者节点，一个用于订阅者节点。在`~/ros2_ws/src/hello_ros2/src`目录中创建`publisher_node.cpp`和`subscriber_node.cpp`文件。

**publisher_node.cpp**

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class PublisherNode : public rclcpp::Node
{
public:
    PublisherNode() : Node("publisher_node"), count_(0)
    {
        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(1000),
            std::bind(&PublisherNode::publish_message, this));
    }

private:
    void publish_message()
    {
        auto message = std_msgs::msg::String();
        message.data = "Hello! ROS2 is fun " + std::to_string(count_++);
        RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
        publisher_->publish(message);
    }

    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    size_t count_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<PublisherNode>());
    rclcpp::shutdown();
    return 0;
}
```

**subscriber_node.cpp**

```cpp
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class SubscriberNode : public rclcpp::Node
{
public:
    SubscriberNode() : Node("subscriber_node")
    {
        subscription_ = this->create_subscription<std_msgs::msg::String>(
            "topic", 10, std::bind(&SubscriberNode::message_callback, this, std::placeholders::_1));
    }

private:
    void message_callback(const std_msgs::msg::String::SharedPtr msg) const
    {
        RCLCPP_INFO(this->get_logger(), "I heard: '%s'", msg->data.c_str());
    }

    rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};

int main(int argc, char * argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<SubscriberNode>());
    rclcpp::shutdown();
    return 0;
}
```

接下来，我们需要更新CMakeLists.txt文件以编译这两个节点。在`~/ros2_ws/src/hello_ros2`目录中，打开CMakeLists.txt文件并添加以下内容：

```cmake
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

add_executable(publisher_node src/publisher_node.cpp)
ament_target_dependencies(publisher_node rclcpp std_msgs)

add_executable(subscriber_node src/subscriber_node.cpp)
ament_target_dependencies(subscriber_node rclcpp std_msgs)

install(TARGETS
  publisher_node
  subscriber_node
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

最后，我们可以构建并运行我们的节点。在你的终端中，运行以下命令：

```bash
cd ~/ros2_ws/
colcon build --packages-select hello_ros2
source install/setup.bash
ros2 run hello_ros2 publisher_node
```

在另一个终端中，运行以下命令：

```bash
source ~/ros2_ws/install/setup.bash
ros2 run hello_ros2 subscriber_node
```

你应该会看到发布者节点发布的消息被订阅者节点接收并打印出来。



task2

在Task 2中，我们将使用Turtlebot3机器人并在rviz2中可视化其激光扫描数据。首先，你需要安装Turtlebot3的ROS2包。在你的终端中，运行以下命令（请将<ros2-distro>替换为你的ROS2发行版，例如foxy或galactic）：

sudo apt install ros-<ros2-distro>-turtlebot3*
然后，你需要在Gazebo中启动Turtlebot3。你可以使用以下命令来启动Turtlebot3的世界：

ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py
接下来，我们将在rviz2中可视化Turtlebot3的激光扫描数据。在新的终端中，运行以下命令：

ros2 run rviz2 rviz2
在rviz2中，你需要添加一个新的显示类型来可视化激光扫描数据。在rviz2的左侧面板中，点击"Add"按钮，然后在弹出的对话框中选择"LaserScan"。在"LaserScan"的属性中，将"Topic"设置为你的激光扫描数据的主题，例如/scan。

请注意，你可能需要根据你的具体设置和需求进行一些调整。例如，你可能需要根据你的ROS2发行版和Turtlebot3的配置更改上述命令中的一些参数。




